#  Java基础

## 1. 数据类型

### 基本类型

- byte/8
- char/16
- short/16
- int/32
- float/32
- long/64
- double/64
- boolean/~

	- boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。

### 包装类型

- 基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。

  //装箱 调用Integer.valueOf(2)
  Integer x = 2; 
  //拆箱 调用 x.intValue()
  int y = x;//

### 缓存池

- new Integer(123) 与 Integer.valueOf(123) 的区别在于：

	- new Integer(123) 每次都会新建一个对象；
	- Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。

	  Integer x = new Integer(123);
	  Integer y = new Integer(123);
	  System.out.println(x == y); //false
	  Integer z = Integer.valueOf(123);
	  Integer k = Integer.valueOf(123);
	  System.out.println(z == k); // true

## 2. String

### 概览

- 存储

	- Java8: char 数组
	- Java9: byte 数组，同时用 coder 来表示使用了那种编码。

### 不可变

### String,StringBuffer, and StringBuilder

可变性
String 不可变
StringBuffer 和 StringBuilder可变

线程安全
String 不可变，因此是线程安全的
StringBuilder 不是线程安全的
StringBuffer 是线程安全的，内部使用synchronized进行同步

## 3. 运算

### 参数传递

- 值传递而不是引用传递

### float 与 double

- 1.1  1.1f

### 隐式类型转换

- += ++ 等操作 自动进行隐式类型转换

### switch

- Java 7 开始，判断语句中可以使用 String

## 4. 关键字

### final

- 数据

	- 对于基本类型，final 使数值不变；
	- 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。

- 方法

	- 声明方法不能被子类重写。
	- private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。

- 类

	- 声明类不允许被继承。

### static

- 静态变量

	- 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。
	- 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。

- 静态方法

	- 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。

- 静态语句块

	- 静态语句块在类初始化时运行一次。

- 静态内部类

	- 非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。

- 静态导包

	- 在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。
	- import static com.xxx.ClassName.*

- 初始化顺序

	- 静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。
	- 存在继承的情况下，初始化顺序为：
	- 父类（静态变量、静态语句块）
	- 子类（静态变量、静态语句块）
	- 父类（实例变量、普通语句块）
	- 父类（构造函数）
	- 子类（实例变量、普通语句块）
	- 子类（构造函数）

## 5. Object 通用方法

### equals()

- 等价关系
- 等价与相等

	- 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。
	- 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。

### hashCode()

- hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。
- 理想的哈希函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。
- R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位，最左边的位丢失。并且一个数与 31 相乘可以转换成移位和减法：31*x == (x<<5)-x，编译器会自动进行这个优化。

### toString()

- 默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。

### clone()

- cloneable

	- clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。
	- clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。

- 浅拷贝

	- 拷贝对象和原始对象的引用类型引用同一个对象。

- 深拷贝

	- 拷贝对象和原始对象的引用类型引用不同对象。

- clone() 的替代方案

	- 使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。

## 11. 特性

### New highlights in Java SE 8

- Lambda Expressions
- Pipelines and Streams
- Date and Time API
- Default Methods
- Type Annotations
- Nashhorn JavaScript Engine
- Concurrent Accumulators
- Parallel operations
- PermGen Error Removed

### New highlights in Java SE 7

- Strings in Switch Statement
- Type Inference for Generic Instance Creation
- Multiple Exception Handling
- Support for Dynamic Languages
- Try with Resources
- Java nio Package
- Binary Literals, Underscore in literals
- Diamond Syntax

## 10. 注解

### Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。

## 9. 泛型

## 8. 异常

### Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：

- 受检异常 ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；
- 非受检异常 ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复

### 

## 7. 反射

### 每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。

### 类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName("com.mysql.jdbc.Driver") 这种方式来控制类的加载，该方法会返回一个 Class 对象。

### 反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。

### Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：

- Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；
- Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；
- Constructor ：可以用 Constructor 的 newInstance() 创建新的对象。

### 反射的优点

- 可扩展性 ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。
- 类浏览器和可视化开发环境 ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。
- 调试器和测试工具 ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。

### 反射的缺点

- 性能开销 ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。
- 安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。
- 内部暴露 ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。

## 6. 继承

### 访问权限

- Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。
- 可以对类或类中的成员（字段和方法）加上访问修饰符。
- 类可见表示其它类可以用这个类创建实例对象。
- 成员可见表示其它类可以用这个类的实例对象访问到该成员；
- protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。
- 设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。
- 如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例去代替，也就是确保满足里氏替换原则。
- 字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。

### 抽象类与接口

- 抽象类

	- 抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。
	- 抽象类和普通类最大的区别是，抽象类不能被实例化，只能被继承。

- 接口

	- 接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。
	- 从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类，让它们都实现新增的方法。
	- 接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。从 Java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。
	- 接口的字段默认都是 static 和 final 的。

- 抽象类和接口的比较

	- 从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。
	- 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。
	- 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。
	- 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。

- 使用选择

	- 使用接口

		- 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Comparable 接口中的 compareTo() 方法；
		- 需要使用多重继承。

	- 使用抽象类

		- 需要在几个相关的类中共享代码。
		- 需要能控制继承来的成员的访问权限，而不是都为 public。
		- 需要继承非静态和非常量字段。

	- 在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。

### super

- 访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。应该注意到，子类一定会调用父类的构造函数来完成初始化工作，一般是调用父类的默认构造函数，如果子类需要调用父类其它构造函数，那么就可以使用 super() 函数。
- 访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。

### 重写与重载

- 重写

	- 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。
	- 为了满足里式替换原则，重写有以下三个限制：

		- 子类方法的访问权限必须大于等于父类方法；
		- 子类方法的返回类型必须是父类方法返回类型或为其子类型。
		- 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。
		- 使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。

- 重载

	- 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。
	- 应该注意的是，返回值不同，其它都相同不算是重载。

## Java 与 C++ 的区别

### Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。

### Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。

### Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。

### Java 支持自动垃圾回收，而 C++ 需要手动回收。

### Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。

### Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。

### Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。

## JRE or JDK

### JRE：Java Runtime Environment，Java 运行环境的简称，为 Java 的运行提供了所需的环境。它是一个 JVM 程序，主要包括了 JVM 的标准实现和一些 Java 基本类库。

### JDK：Java Development Kit，Java 开发工具包，提供了 Java 的开发及运行环境。JDK 是 Java 开发的核心，集成了 JRE 以及一些其它的工具，比如编译 Java 源码的编译器 javac 等。

